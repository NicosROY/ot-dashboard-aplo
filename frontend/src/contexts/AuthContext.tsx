import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { User, AuthContextType } from '../types';
import supabaseService from '../services/supabase';
import onboardingService from '../services/onboardingService';

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  console.log('üîÑ AuthProvider rendu');
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [onboardingStatus, setOnboardingStatus] = useState<'checking' | 'complete' | 'incomplete'>('checking');
  const [onboardingStep, setOnboardingStep] = useState<number>(0);
  const [isCheckingUserStatus, setIsCheckingUserStatus] = useState(false); // Flag pour √©viter le double appel
  const [hasProcessedSignIn, setHasProcessedSignIn] = useState(false); // Flag pour √©viter la boucle
  const [hasInitialized, setHasInitialized] = useState(false); // Flag pour √©viter l'initialisation en boucle

  // √âcouter les changements d'√©tat d'authentification
  useEffect(() => {
    // √âviter l'initialisation en boucle
    if (hasInitialized) {
      console.log('üö´ AuthProvider d√©j√† initialis√©, ignor√©');
      return;
    }
    
    console.log('üîç Configuration de l\'√©couteur d\'authentification...');
    setHasInitialized(true);
    
    const { data: { subscription } } = supabaseService.getClient().auth.onAuthStateChange(
      async (event, session) => {
        console.log('üîÑ √âv√©nement d\'authentification:', event, 'Session:', session?.user?.email);
        
        if (event === 'SIGNED_IN' && session) {
          console.log('‚úÖ Utilisateur connect√©:', session.user.email);
          
          // √âviter la boucle infinie
          if (hasProcessedSignIn) {
            console.log('üö´ SIGNED_IN d√©j√† trait√©, ignor√©');
            return;
          }
          
          setHasProcessedSignIn(true);
          
          // V√©rifier imm√©diatement le statut d'authentification et d'onboarding
          await checkUserStatus(session.user.id);
          
        } else if (event === 'SIGNED_OUT') {
          console.log('‚ùå Utilisateur d√©connect√©');
          setUser(null);
          setToken(null);
          setOnboardingStatus('incomplete');
          setOnboardingStep(0);
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          setIsLoading(false);
        } else if (event === 'TOKEN_REFRESHED' && session) {
          console.log('üîÑ Token rafra√Æchi');
          // Stocker le token SEULEMENT si l√©gitime
          if (user || onboardingStatus === 'incomplete') {
            setToken(session.access_token);
          }
        }
      }
    );

    // D√©clencher une v√©rification initiale de la session
    supabaseService.getClient().auth.getSession().then(async ({ data: { session } }) => {
      console.log('üîç Session initiale:', session?.user?.email || 'AUCUNE');
      if (session) {
        // Ne pas appeler checkUserStatus ici, onAuthStateChange s'en chargera
        console.log('üîç Session trouv√©e, onAuthStateChange va se d√©clencher');
        setIsLoading(false);
      } else {
        console.log('üèÅ Pas de session initiale, setIsLoading(false)');
        setIsLoading(false);
      }
    }).catch((error) => {
      console.error('‚ùå Erreur session initiale:', error);
      setIsLoading(false);
    });

    // Nettoyer l'abonnement au d√©montage
    return () => subscription.unsubscribe();
  }, []);

  // Redirection automatique bas√©e sur les changements d'√©tat
  useEffect(() => {
    if (!isLoading) {
      if (onboardingStatus === 'incomplete') {
        console.log('üöÄ Redirection automatique vers /onboarding (useEffect)');
        window.location.href = '/onboarding';
      } else if (user) {
        console.log('üöÄ Redirection automatique vers /dashboard (useEffect)');
        window.location.href = '/dashboard';
      }
    }
  }, [isLoading, onboardingStatus, user]);

  // Fonction pour v√©rifier le statut complet de l'utilisateur
  const checkUserStatus = useCallback(async (userId: string) => {
    // √âviter le double appel
    if (isCheckingUserStatus) {
      console.log('üö´ checkUserStatus d√©j√† en cours, ignor√©');
      return;
    }
    
    console.log('üöÄ D√âBUT checkUserStatus appel√© avec userId:', userId);
    setIsCheckingUserStatus(true);
    
    // TIMEOUT de s√©curit√© : si √ßa prend plus de 2 secondes, on arr√™te
    const timeoutId = setTimeout(() => {
      console.error('‚è∞ TIMEOUT checkUserStatus apr√®s 2s - arr√™t forc√©');
      setUser(null);
      setOnboardingStatus('incomplete');
      setOnboardingStep(0);
      setToken(null);
      setIsLoading(false);
      setIsCheckingUserStatus(false);
    }, 2000);
    
    try {
      console.log('üîç V√©rification du statut utilisateur pour:', userId);
      
      // 1. V√©rifier si l'utilisateur a un profil complet
      console.log('üîç Requ√™te user_profiles en cours...');
      let userProfileResponse;
      try {
        console.log('üîç Appel Supabase user_profiles...');
        userProfileResponse = await supabaseService.getClient()
          .from('user_profiles')
          .select('*')
          .eq('id', userId)
          .single();
        
        console.log('üîç R√©ponse user_profiles re√ßue:', userProfileResponse);
        console.log('üîç userProfileResponse.data:', userProfileResponse.data);
        console.log('üîç userProfileResponse.error:', userProfileResponse.error);
      } catch (error) {
        console.error('‚ùå ERREUR requ√™te user_profiles:', error);
        throw error;
      }
      
      const { data: userProfile, error: profileError } = userProfileResponse;
      console.log('üë§ Profil utilisateur:', userProfile);
      console.log('‚ùå Erreur profil:', profileError);

      if (profileError || !userProfile) {
        console.log('Profil utilisateur non trouv√©, v√©rification onboarding_progress...');
        
        // Si pas de user_profiles, v√©rifier onboarding_progress
        console.log('üîç Requ√™te onboarding_progress en cours...');
        const { data: onboardingProgress, error: onboardingError } = await supabaseService.getClient()
          .from('onboarding_progress')
          .select('*')
          .eq('id', userId)
          .maybeSingle();

        console.log('üìã Onboarding progress:', onboardingProgress);
        
        if (onboardingProgress) {
          console.log('Onboarding en cours d√©tect√©, √©tape:', onboardingProgress.current_step);
          setUser(null); // Pas de user_profile = pas authentifi√©
          setOnboardingStatus('incomplete');
          setOnboardingStep(onboardingProgress.current_step || 0);
          
          // Stocker le token SEULEMENT si onboarding_progress existe (lien mail)
          const { data: { session } } = await supabaseService.getClient().auth.getSession();
          if (session) {
            setToken(session.access_token);
            console.log('üîë Token stock√© car onboarding_progress existe (lien mail)');
          }
          
          console.log('üöÄ √âtats mis √† jour : user=null, onboardingStatus=incomplete, isLoading va devenir false');
          console.log('üîç V√©rification des √©tats apr√®s setState...');
          console.log('üîç user va devenir:', null);
          console.log('üîç onboardingStatus va devenir: incomplete');
          console.log('üîç onboardingStep va devenir:', onboardingProgress.current_step || 0);
        } else {
          console.log('Aucun profil ni onboarding trouv√©');
          setUser(null);
          setOnboardingStatus('incomplete');
          setOnboardingStep(0);
          // NE PAS stocker le token si rien n'existe
          setToken(null);
        }
      } else {
        // 2. Si user_profiles existe ‚Üí DASHBOARD (point final)
        console.log('‚úÖ User profile trouv√©, onboarding complet');
        setUser(userProfile);
        setOnboardingStatus('complete');
        setOnboardingStep(0);
        
        // Stocker le token car user_profile existe
        const { data: { session } } = await supabaseService.getClient().auth.getSession();
        if (session) {
          setToken(session.access_token);
          console.log('üîë Token stock√© car user_profile existe');
        }
      }
      
      // ARR√äTER le chargement apr√®s v√©rification
      console.log('üèÅ FIN checkUserStatus - setIsLoading(false)');
      console.log('üîç Juste avant setIsLoading(false)');
      clearTimeout(timeoutId); // Nettoyer le timeout
      setIsLoading(false);
      console.log('üîç Apr√®s setIsLoading(false)');
      setIsCheckingUserStatus(false);
      console.log('üîç Apr√®s setIsCheckingUserStatus(false)');
      
      // Les √©tats sont mis √† jour, la redirection se fera via useEffect
    } catch (error) {
      console.error('Erreur lors de la v√©rification du statut utilisateur:', error);
      clearTimeout(timeoutId); // Nettoyer le timeout m√™me en cas d'erreur
      setUser(null);
      setOnboardingStatus('incomplete');
      setOnboardingStep(0);
      setToken(null); // NE PAS stocker le token en cas d'erreur
      setIsLoading(false); // ARR√äTER le chargement m√™me en cas d'erreur
      setIsCheckingUserStatus(false);
    }
  }, []);



  const login = async (email: string, password: string) => {
    try {
      const response = await supabaseService.login(email, password);
      
      if (response.success) {
        // D√©clencher onAuthStateChange en r√©cup√©rant la session
        const { data: { session } } = await supabaseService.getClient().auth.getSession();
        if (session) {
          console.log('üîë Session r√©cup√©r√©e apr√®s login, onAuthStateChange va se d√©clencher');
        }
        return response;
      } else {
        throw new Error('√âchec de la connexion');
      }
    } catch (error) {
      console.error('Erreur de connexion:', error);
      throw error;
    }
  };

  const logout = async () => {
    try {
      // UTILISER le token SEULEMENT si user_profile existe
      if (user && token) {
        await supabaseService.logout();
      }
    } catch (error) {
      console.error('Erreur lors de la d√©connexion:', error);
    } finally {
      // Nettoyage local
      setUser(null);
      setToken(null);
      setOnboardingStatus('incomplete');
      setOnboardingStep(0);
      localStorage.removeItem('token');
      localStorage.removeItem('user');
    }
  };

  // Fonction pour rafra√Æchir le statut d'onboarding
  const refreshOnboardingStatus = async () => {
    // UTILISER le token SEULEMENT si user_profile existe
    if (user && token) {
      const { data: { user: authUser } } = await supabaseService.getClient().auth.getUser();
      if (authUser) {
        await checkUserStatus(authUser.id);
      }
    }
  };

  const SUPERADMIN_ID = '39d145c4-20d9-495a-9a57-5c4cd3553089';
  
  // LOGIQUE CLAIRE : isAuthenticated = true seulement si user_profile existe
  const value: AuthContextType = {
    user,
    token,
    login,
    logout,
    isLoading,
    isAuthenticated: !!user, // SEULEMENT si user_profile existe
    onboardingStatus,
    isOnboardingComplete: onboardingStatus === 'complete',
    onboardingStep, // Nouvelle propri√©t√© pour l'√©tape sauvegard√©e
    refreshOnboardingStatus,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth doit √™tre utilis√© dans un AuthProvider');
  }
  return context;
}; 